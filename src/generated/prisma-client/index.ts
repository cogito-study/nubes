// Code generated by Prisma (prisma@1.23.4). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  note: (where?: NoteWhereInput) => Promise<boolean>;
  subject: (where?: SubjectWhereInput) => Promise<boolean>;
  subjectInfo: (where?: SubjectInfoWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  comment: (where: CommentWhereUniqueInput) => CommentPromise;
  comments: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Comment>;
  commentsConnection: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CommentConnectionPromise;
  note: (where: NoteWhereUniqueInput) => NotePromise;
  notes: (
    args?: {
      where?: NoteWhereInput;
      orderBy?: NoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Note>;
  notesConnection: (
    args?: {
      where?: NoteWhereInput;
      orderBy?: NoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => NoteConnectionPromise;
  subject: (where: SubjectWhereUniqueInput) => SubjectPromise;
  subjects: (
    args?: {
      where?: SubjectWhereInput;
      orderBy?: SubjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Subject>;
  subjectsConnection: (
    args?: {
      where?: SubjectWhereInput;
      orderBy?: SubjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SubjectConnectionPromise;
  subjectInfo: (where: SubjectInfoWhereUniqueInput) => SubjectInfoPromise;
  subjectInfoes: (
    args?: {
      where?: SubjectInfoWhereInput;
      orderBy?: SubjectInfoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SubjectInfo>;
  subjectInfoesConnection: (
    args?: {
      where?: SubjectInfoWhereInput;
      orderBy?: SubjectInfoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SubjectInfoConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (
    args: { data: CommentUpdateInput; where: CommentWhereUniqueInput }
  ) => CommentPromise;
  updateManyComments: (
    args: { data: CommentUpdateManyMutationInput; where?: CommentWhereInput }
  ) => BatchPayloadPromise;
  upsertComment: (
    args: {
      where: CommentWhereUniqueInput;
      create: CommentCreateInput;
      update: CommentUpdateInput;
    }
  ) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createNote: (data: NoteCreateInput) => NotePromise;
  updateNote: (
    args: { data: NoteUpdateInput; where: NoteWhereUniqueInput }
  ) => NotePromise;
  updateManyNotes: (
    args: { data: NoteUpdateManyMutationInput; where?: NoteWhereInput }
  ) => BatchPayloadPromise;
  upsertNote: (
    args: {
      where: NoteWhereUniqueInput;
      create: NoteCreateInput;
      update: NoteUpdateInput;
    }
  ) => NotePromise;
  deleteNote: (where: NoteWhereUniqueInput) => NotePromise;
  deleteManyNotes: (where?: NoteWhereInput) => BatchPayloadPromise;
  createSubject: (data: SubjectCreateInput) => SubjectPromise;
  updateSubject: (
    args: { data: SubjectUpdateInput; where: SubjectWhereUniqueInput }
  ) => SubjectPromise;
  updateManySubjects: (
    args: { data: SubjectUpdateManyMutationInput; where?: SubjectWhereInput }
  ) => BatchPayloadPromise;
  upsertSubject: (
    args: {
      where: SubjectWhereUniqueInput;
      create: SubjectCreateInput;
      update: SubjectUpdateInput;
    }
  ) => SubjectPromise;
  deleteSubject: (where: SubjectWhereUniqueInput) => SubjectPromise;
  deleteManySubjects: (where?: SubjectWhereInput) => BatchPayloadPromise;
  createSubjectInfo: (data: SubjectInfoCreateInput) => SubjectInfoPromise;
  updateSubjectInfo: (
    args: { data: SubjectInfoUpdateInput; where: SubjectInfoWhereUniqueInput }
  ) => SubjectInfoPromise;
  updateManySubjectInfoes: (
    args: {
      data: SubjectInfoUpdateManyMutationInput;
      where?: SubjectInfoWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSubjectInfo: (
    args: {
      where: SubjectInfoWhereUniqueInput;
      create: SubjectInfoCreateInput;
      update: SubjectInfoUpdateInput;
    }
  ) => SubjectInfoPromise;
  deleteSubjectInfo: (where: SubjectInfoWhereUniqueInput) => SubjectInfoPromise;
  deleteManySubjectInfoes: (
    where?: SubjectInfoWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  note: (
    where?: NoteSubscriptionWhereInput
  ) => NoteSubscriptionPayloadSubscription;
  subject: (
    where?: SubjectSubscriptionWhereInput
  ) => SubjectSubscriptionPayloadSubscription;
  subjectInfo: (
    where?: SubjectInfoSubscriptionWhereInput
  ) => SubjectInfoSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UserRole = "USER" | "ADMIN";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "neptun_ASC"
  | "neptun_DESC"
  | "password_ASC"
  | "password_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "role_ASC"
  | "role_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NoteType = "NOTE" | "CASE_STUDY";

export type SubjectInfoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "subtitle_ASC"
  | "subtitle_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "title_ASC"
  | "title_DESC"
  | "number_ASC"
  | "number_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC";

export type SubjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "locationInText_ASC"
  | "locationInText_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NoteCreateWithoutSubjectInput {
  text: Json;
  title: String;
  number: Int;
  description?: String;
  author: UserCreateOneInput;
  comments?: CommentCreateManyWithoutNoteInput;
  type: NoteType;
  upvotes?: UserCreateManyInput;
}

export interface SubjectScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
  OR?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
  NOT?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
}

export interface CommentCreateManyWithoutNoteInput {
  create?: CommentCreateWithoutNoteInput[] | CommentCreateWithoutNoteInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface SubjectInfoUpdateWithWhereUniqueWithoutSubjectInput {
  where: SubjectInfoWhereUniqueInput;
  data: SubjectInfoUpdateWithoutSubjectDataInput;
}

export interface CommentCreateWithoutNoteInput {
  text: String;
  locationInText: Json;
  author: UserCreateOneInput;
  replies?: CommentCreateManyInput;
  upvotes?: UserCreateManyInput;
}

export interface SubjectInfoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  subtitle?: String;
  subtitle_not?: String;
  subtitle_in?: String[] | String;
  subtitle_not_in?: String[] | String;
  subtitle_lt?: String;
  subtitle_lte?: String;
  subtitle_gt?: String;
  subtitle_gte?: String;
  subtitle_contains?: String;
  subtitle_not_contains?: String;
  subtitle_starts_with?: String;
  subtitle_not_starts_with?: String;
  subtitle_ends_with?: String;
  subtitle_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  subject?: SubjectWhereInput;
  AND?: SubjectInfoWhereInput[] | SubjectInfoWhereInput;
  OR?: SubjectInfoWhereInput[] | SubjectInfoWhereInput;
  NOT?: SubjectInfoWhereInput[] | SubjectInfoWhereInput;
}

export interface CommentCreateManyInput {
  create?: CommentCreateInput[] | CommentCreateInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface NoteWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  number?: Int;
  number_not?: Int;
  number_in?: Int[] | Int;
  number_not_in?: Int[] | Int;
  number_lt?: Int;
  number_lte?: Int;
  number_gt?: Int;
  number_gte?: Int;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  author?: UserWhereInput;
  subject?: SubjectWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  type?: NoteType;
  type_not?: NoteType;
  type_in?: NoteType[] | NoteType;
  type_not_in?: NoteType[] | NoteType;
  upvotes_every?: UserWhereInput;
  upvotes_some?: UserWhereInput;
  upvotes_none?: UserWhereInput;
  AND?: NoteWhereInput[] | NoteWhereInput;
  OR?: NoteWhereInput[] | NoteWhereInput;
  NOT?: NoteWhereInput[] | NoteWhereInput;
}

export interface CommentUpdateInput {
  text?: String;
  locationInText?: Json;
  note?: NoteUpdateOneRequiredWithoutCommentsInput;
  author?: UserUpdateOneRequiredInput;
  replies?: CommentUpdateManyInput;
  upvotes?: UserUpdateManyInput;
}

export interface SubjectInfoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SubjectInfoWhereInput;
  AND?: SubjectInfoSubscriptionWhereInput[] | SubjectInfoSubscriptionWhereInput;
  OR?: SubjectInfoSubscriptionWhereInput[] | SubjectInfoSubscriptionWhereInput;
  NOT?: SubjectInfoSubscriptionWhereInput[] | SubjectInfoSubscriptionWhereInput;
}

export interface NoteUpdateOneRequiredWithoutCommentsInput {
  create?: NoteCreateWithoutCommentsInput;
  update?: NoteUpdateWithoutCommentsDataInput;
  upsert?: NoteUpsertWithoutCommentsInput;
  connect?: NoteWhereUniqueInput;
}

export interface NoteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NoteWhereInput;
  AND?: NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput;
  OR?: NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput;
  NOT?: NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput;
}

export interface NoteUpdateWithoutCommentsDataInput {
  text?: Json;
  title?: String;
  number?: Int;
  description?: String;
  author?: UserUpdateOneRequiredInput;
  subject?: SubjectUpdateOneRequiredWithoutNotesInput;
  type?: NoteType;
  upvotes?: UserUpdateManyInput;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  neptun?: String;
  password?: String;
  firstName?: String;
  lastName?: String;
  role?: UserRole;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface SubjectInfoUpdateManyMutationInput {
  title?: String;
  subtitle?: String;
  text?: String;
}

export interface UserUpdateDataInput {
  email?: String;
  neptun?: String;
  password?: String;
  firstName?: String;
  lastName?: String;
  role?: UserRole;
}

export interface SubjectUpdateWithoutInfoDataInput {
  code?: String;
  name?: String;
  description?: String;
  faculty?: UserUpdateManyInput;
  students?: UserUpdateManyInput;
  notes?: NoteUpdateManyWithoutSubjectInput;
  prerequisites?: SubjectUpdateManyInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface SubjectInfoUpdateInput {
  title?: String;
  subtitle?: String;
  text?: String;
  subject?: SubjectUpdateOneRequiredWithoutInfoInput;
}

export interface SubjectUpdateOneRequiredWithoutNotesInput {
  create?: SubjectCreateWithoutNotesInput;
  update?: SubjectUpdateWithoutNotesDataInput;
  upsert?: SubjectUpsertWithoutNotesInput;
  connect?: SubjectWhereUniqueInput;
}

export interface SubjectCreateWithoutInfoInput {
  code: String;
  name: String;
  description: String;
  faculty?: UserCreateManyInput;
  students?: UserCreateManyInput;
  notes?: NoteCreateManyWithoutSubjectInput;
  prerequisites?: SubjectCreateManyInput;
}

export interface SubjectUpdateWithoutNotesDataInput {
  code?: String;
  name?: String;
  description?: String;
  faculty?: UserUpdateManyInput;
  students?: UserUpdateManyInput;
  info?: SubjectInfoUpdateManyWithoutSubjectInput;
  prerequisites?: SubjectUpdateManyInput;
}

export interface SubjectInfoCreateInput {
  title: String;
  subtitle?: String;
  text: String;
  subject: SubjectCreateOneWithoutInfoInput;
}

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface SubjectUpdateManyMutationInput {
  code?: String;
  name?: String;
  description?: String;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface NoteUpdateManyMutationInput {
  text?: Json;
  title?: String;
  number?: Int;
  description?: String;
  type?: NoteType;
}

export interface SubjectUpdateManyWithWhereNestedInput {
  where: SubjectScalarWhereInput;
  data: SubjectUpdateManyDataInput;
}

export interface NoteUpdateInput {
  text?: Json;
  title?: String;
  number?: Int;
  description?: String;
  author?: UserUpdateOneRequiredInput;
  subject?: SubjectUpdateOneRequiredWithoutNotesInput;
  comments?: CommentUpdateManyWithoutNoteInput;
  type?: NoteType;
  upvotes?: UserUpdateManyInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  neptun?: String;
  neptun_not?: String;
  neptun_in?: String[] | String;
  neptun_not_in?: String[] | String;
  neptun_lt?: String;
  neptun_lte?: String;
  neptun_gt?: String;
  neptun_gte?: String;
  neptun_contains?: String;
  neptun_not_contains?: String;
  neptun_starts_with?: String;
  neptun_not_starts_with?: String;
  neptun_ends_with?: String;
  neptun_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  role?: UserRole;
  role_not?: UserRole;
  role_in?: UserRole[] | UserRole;
  role_not_in?: UserRole[] | UserRole;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface CommentUpdateManyMutationInput {
  text?: String;
  locationInText?: Json;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface NoteUpsertWithoutCommentsInput {
  update: NoteUpdateWithoutCommentsDataInput;
  create: NoteCreateWithoutCommentsInput;
}

export interface UserUpdateManyDataInput {
  email?: String;
  neptun?: String;
  password?: String;
  firstName?: String;
  lastName?: String;
  role?: UserRole;
}

export interface SubjectUpdateManyDataInput {
  code?: String;
  name?: String;
  description?: String;
}

export interface SubjectInfoUpdateManyWithoutSubjectInput {
  create?:
    | SubjectInfoCreateWithoutSubjectInput[]
    | SubjectInfoCreateWithoutSubjectInput;
  delete?: SubjectInfoWhereUniqueInput[] | SubjectInfoWhereUniqueInput;
  connect?: SubjectInfoWhereUniqueInput[] | SubjectInfoWhereUniqueInput;
  disconnect?: SubjectInfoWhereUniqueInput[] | SubjectInfoWhereUniqueInput;
  update?:
    | SubjectInfoUpdateWithWhereUniqueWithoutSubjectInput[]
    | SubjectInfoUpdateWithWhereUniqueWithoutSubjectInput;
  upsert?:
    | SubjectInfoUpsertWithWhereUniqueWithoutSubjectInput[]
    | SubjectInfoUpsertWithWhereUniqueWithoutSubjectInput;
  deleteMany?: SubjectInfoScalarWhereInput[] | SubjectInfoScalarWhereInput;
  updateMany?:
    | SubjectInfoUpdateManyWithWhereNestedInput[]
    | SubjectInfoUpdateManyWithWhereNestedInput;
}

export interface CommentCreateInput {
  text: String;
  locationInText: Json;
  note: NoteCreateOneWithoutCommentsInput;
  author: UserCreateOneInput;
  replies?: CommentCreateManyInput;
  upvotes?: UserCreateManyInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  neptun?: String;
  neptun_not?: String;
  neptun_in?: String[] | String;
  neptun_not_in?: String[] | String;
  neptun_lt?: String;
  neptun_lte?: String;
  neptun_gt?: String;
  neptun_gte?: String;
  neptun_contains?: String;
  neptun_not_contains?: String;
  neptun_starts_with?: String;
  neptun_not_starts_with?: String;
  neptun_ends_with?: String;
  neptun_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  role?: UserRole;
  role_not?: UserRole;
  role_in?: UserRole[] | UserRole;
  role_not_in?: UserRole[] | UserRole;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface NoteCreateWithoutCommentsInput {
  text: Json;
  title: String;
  number: Int;
  description?: String;
  author: UserCreateOneInput;
  subject: SubjectCreateOneWithoutNotesInput;
  type: NoteType;
  upvotes?: UserCreateManyInput;
}

export interface SubjectInfoUpdateWithoutSubjectDataInput {
  title?: String;
  subtitle?: String;
  text?: String;
}

export interface UserCreateInput {
  email: String;
  neptun: String;
  password: String;
  firstName?: String;
  lastName?: String;
  role?: UserRole;
}

export interface SubjectInfoUpsertWithWhereUniqueWithoutSubjectInput {
  where: SubjectInfoWhereUniqueInput;
  update: SubjectInfoUpdateWithoutSubjectDataInput;
  create: SubjectInfoCreateWithoutSubjectInput;
}

export interface SubjectCreateWithoutNotesInput {
  code: String;
  name: String;
  description: String;
  faculty?: UserCreateManyInput;
  students?: UserCreateManyInput;
  info?: SubjectInfoCreateManyWithoutSubjectInput;
  prerequisites?: SubjectCreateManyInput;
}

export interface SubjectInfoScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  subtitle?: String;
  subtitle_not?: String;
  subtitle_in?: String[] | String;
  subtitle_not_in?: String[] | String;
  subtitle_lt?: String;
  subtitle_lte?: String;
  subtitle_gt?: String;
  subtitle_gte?: String;
  subtitle_contains?: String;
  subtitle_not_contains?: String;
  subtitle_starts_with?: String;
  subtitle_not_starts_with?: String;
  subtitle_ends_with?: String;
  subtitle_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: SubjectInfoScalarWhereInput[] | SubjectInfoScalarWhereInput;
  OR?: SubjectInfoScalarWhereInput[] | SubjectInfoScalarWhereInput;
  NOT?: SubjectInfoScalarWhereInput[] | SubjectInfoScalarWhereInput;
}

export interface SubjectInfoCreateManyWithoutSubjectInput {
  create?:
    | SubjectInfoCreateWithoutSubjectInput[]
    | SubjectInfoCreateWithoutSubjectInput;
  connect?: SubjectInfoWhereUniqueInput[] | SubjectInfoWhereUniqueInput;
}

export interface SubjectInfoUpdateManyWithWhereNestedInput {
  where: SubjectInfoScalarWhereInput;
  data: SubjectInfoUpdateManyDataInput;
}

export interface SubjectCreateManyInput {
  create?: SubjectCreateInput[] | SubjectCreateInput;
  connect?: SubjectWhereUniqueInput[] | SubjectWhereUniqueInput;
}

export interface SubjectInfoUpdateManyDataInput {
  title?: String;
  subtitle?: String;
  text?: String;
}

export interface NoteCreateManyWithoutSubjectInput {
  create?: NoteCreateWithoutSubjectInput[] | NoteCreateWithoutSubjectInput;
  connect?: NoteWhereUniqueInput[] | NoteWhereUniqueInput;
}

export interface SubjectUpdateManyInput {
  create?: SubjectCreateInput[] | SubjectCreateInput;
  update?:
    | SubjectUpdateWithWhereUniqueNestedInput[]
    | SubjectUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SubjectUpsertWithWhereUniqueNestedInput[]
    | SubjectUpsertWithWhereUniqueNestedInput;
  delete?: SubjectWhereUniqueInput[] | SubjectWhereUniqueInput;
  connect?: SubjectWhereUniqueInput[] | SubjectWhereUniqueInput;
  disconnect?: SubjectWhereUniqueInput[] | SubjectWhereUniqueInput;
  deleteMany?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
  updateMany?:
    | SubjectUpdateManyWithWhereNestedInput[]
    | SubjectUpdateManyWithWhereNestedInput;
}

export interface SubjectWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  faculty_every?: UserWhereInput;
  faculty_some?: UserWhereInput;
  faculty_none?: UserWhereInput;
  students_every?: UserWhereInput;
  students_some?: UserWhereInput;
  students_none?: UserWhereInput;
  info_every?: SubjectInfoWhereInput;
  info_some?: SubjectInfoWhereInput;
  info_none?: SubjectInfoWhereInput;
  notes_every?: NoteWhereInput;
  notes_some?: NoteWhereInput;
  notes_none?: NoteWhereInput;
  prerequisites_every?: SubjectWhereInput;
  prerequisites_some?: SubjectWhereInput;
  prerequisites_none?: SubjectWhereInput;
  AND?: SubjectWhereInput[] | SubjectWhereInput;
  OR?: SubjectWhereInput[] | SubjectWhereInput;
  NOT?: SubjectWhereInput[] | SubjectWhereInput;
}

export interface SubjectUpdateWithWhereUniqueNestedInput {
  where: SubjectWhereUniqueInput;
  data: SubjectUpdateDataInput;
}

export interface SubjectSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SubjectWhereInput;
  AND?: SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput;
  OR?: SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput;
  NOT?: SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput;
}

export interface SubjectUpdateDataInput {
  code?: String;
  name?: String;
  description?: String;
  faculty?: UserUpdateManyInput;
  students?: UserUpdateManyInput;
  info?: SubjectInfoUpdateManyWithoutSubjectInput;
  notes?: NoteUpdateManyWithoutSubjectInput;
  prerequisites?: SubjectUpdateManyInput;
}

export interface UserUpdateInput {
  email?: String;
  neptun?: String;
  password?: String;
  firstName?: String;
  lastName?: String;
  role?: UserRole;
}

export interface NoteUpdateManyWithoutSubjectInput {
  create?: NoteCreateWithoutSubjectInput[] | NoteCreateWithoutSubjectInput;
  delete?: NoteWhereUniqueInput[] | NoteWhereUniqueInput;
  connect?: NoteWhereUniqueInput[] | NoteWhereUniqueInput;
  disconnect?: NoteWhereUniqueInput[] | NoteWhereUniqueInput;
  update?:
    | NoteUpdateWithWhereUniqueWithoutSubjectInput[]
    | NoteUpdateWithWhereUniqueWithoutSubjectInput;
  upsert?:
    | NoteUpsertWithWhereUniqueWithoutSubjectInput[]
    | NoteUpsertWithWhereUniqueWithoutSubjectInput;
  deleteMany?: NoteScalarWhereInput[] | NoteScalarWhereInput;
  updateMany?:
    | NoteUpdateManyWithWhereNestedInput[]
    | NoteUpdateManyWithWhereNestedInput;
}

export interface SubjectUpdateOneRequiredWithoutInfoInput {
  create?: SubjectCreateWithoutInfoInput;
  update?: SubjectUpdateWithoutInfoDataInput;
  upsert?: SubjectUpsertWithoutInfoInput;
  connect?: SubjectWhereUniqueInput;
}

export interface NoteUpdateWithWhereUniqueWithoutSubjectInput {
  where: NoteWhereUniqueInput;
  data: NoteUpdateWithoutSubjectDataInput;
}

export interface SubjectCreateOneWithoutInfoInput {
  create?: SubjectCreateWithoutInfoInput;
  connect?: SubjectWhereUniqueInput;
}

export interface NoteUpdateWithoutSubjectDataInput {
  text?: Json;
  title?: String;
  number?: Int;
  description?: String;
  author?: UserUpdateOneRequiredInput;
  comments?: CommentUpdateManyWithoutNoteInput;
  type?: NoteType;
  upvotes?: UserUpdateManyInput;
}

export interface SubjectUpdateInput {
  code?: String;
  name?: String;
  description?: String;
  faculty?: UserUpdateManyInput;
  students?: UserUpdateManyInput;
  info?: SubjectInfoUpdateManyWithoutSubjectInput;
  notes?: NoteUpdateManyWithoutSubjectInput;
  prerequisites?: SubjectUpdateManyInput;
}

export interface CommentUpdateManyWithoutNoteInput {
  create?: CommentCreateWithoutNoteInput[] | CommentCreateWithoutNoteInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutNoteInput[]
    | CommentUpdateWithWhereUniqueWithoutNoteInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutNoteInput[]
    | CommentUpsertWithWhereUniqueWithoutNoteInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface NoteCreateInput {
  text: Json;
  title: String;
  number: Int;
  description?: String;
  author: UserCreateOneInput;
  subject: SubjectCreateOneWithoutNotesInput;
  comments?: CommentCreateManyWithoutNoteInput;
  type: NoteType;
  upvotes?: UserCreateManyInput;
}

export interface CommentUpdateWithWhereUniqueWithoutNoteInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutNoteDataInput;
}

export interface SubjectUpsertWithoutNotesInput {
  update: SubjectUpdateWithoutNotesDataInput;
  create: SubjectCreateWithoutNotesInput;
}

export interface CommentUpdateWithoutNoteDataInput {
  text?: String;
  locationInText?: Json;
  author?: UserUpdateOneRequiredInput;
  replies?: CommentUpdateManyInput;
  upvotes?: UserUpdateManyInput;
}

export interface NoteCreateOneWithoutCommentsInput {
  create?: NoteCreateWithoutCommentsInput;
  connect?: NoteWhereUniqueInput;
}

export interface CommentUpdateManyInput {
  create?: CommentCreateInput[] | CommentCreateInput;
  update?:
    | CommentUpdateWithWhereUniqueNestedInput[]
    | CommentUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CommentUpsertWithWhereUniqueNestedInput[]
    | CommentUpsertWithWhereUniqueNestedInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface SubjectCreateOneWithoutNotesInput {
  create?: SubjectCreateWithoutNotesInput;
  connect?: SubjectWhereUniqueInput;
}

export interface CommentUpdateWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateDataInput;
}

export interface SubjectInfoCreateWithoutSubjectInput {
  title: String;
  subtitle?: String;
  text: String;
}

export interface CommentUpdateDataInput {
  text?: String;
  locationInText?: Json;
  note?: NoteUpdateOneRequiredWithoutCommentsInput;
  author?: UserUpdateOneRequiredInput;
  replies?: CommentUpdateManyInput;
  upvotes?: UserUpdateManyInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface CommentUpsertWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateDataInput;
  create: CommentCreateInput;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommentWhereInput;
  AND?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  OR?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  NOT?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
}

export interface CommentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  OR?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  NOT?: CommentScalarWhereInput[] | CommentScalarWhereInput;
}

export type NoteWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export type SubjectInfoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CommentUpdateManyDataInput {
  text?: String;
  locationInText?: Json;
}

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface CommentUpsertWithWhereUniqueWithoutNoteInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutNoteDataInput;
  create: CommentCreateWithoutNoteInput;
}

export interface CommentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  note?: NoteWhereInput;
  author?: UserWhereInput;
  replies_every?: CommentWhereInput;
  replies_some?: CommentWhereInput;
  replies_none?: CommentWhereInput;
  upvotes_every?: UserWhereInput;
  upvotes_some?: UserWhereInput;
  upvotes_none?: UserWhereInput;
  AND?: CommentWhereInput[] | CommentWhereInput;
  OR?: CommentWhereInput[] | CommentWhereInput;
  NOT?: CommentWhereInput[] | CommentWhereInput;
}

export interface NoteUpsertWithWhereUniqueWithoutSubjectInput {
  where: NoteWhereUniqueInput;
  update: NoteUpdateWithoutSubjectDataInput;
  create: NoteCreateWithoutSubjectInput;
}

export type SubjectWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface SubjectUpsertWithWhereUniqueNestedInput {
  where: SubjectWhereUniqueInput;
  update: SubjectUpdateDataInput;
  create: SubjectCreateInput;
}

export interface NoteUpdateManyDataInput {
  text?: Json;
  title?: String;
  number?: Int;
  description?: String;
  type?: NoteType;
}

export interface NoteUpdateManyWithWhereNestedInput {
  where: NoteScalarWhereInput;
  data: NoteUpdateManyDataInput;
}

export interface NoteScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  number?: Int;
  number_not?: Int;
  number_in?: Int[] | Int;
  number_not_in?: Int[] | Int;
  number_lt?: Int;
  number_lte?: Int;
  number_gt?: Int;
  number_gte?: Int;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: NoteType;
  type_not?: NoteType;
  type_in?: NoteType[] | NoteType;
  type_not_in?: NoteType[] | NoteType;
  AND?: NoteScalarWhereInput[] | NoteScalarWhereInput;
  OR?: NoteScalarWhereInput[] | NoteScalarWhereInput;
  NOT?: NoteScalarWhereInput[] | NoteScalarWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
  neptun?: String;
}>;

export interface SubjectUpsertWithoutInfoInput {
  update: SubjectUpdateWithoutInfoDataInput;
  create: SubjectCreateWithoutInfoInput;
}

export interface SubjectCreateInput {
  code: String;
  name: String;
  description: String;
  faculty?: UserCreateManyInput;
  students?: UserCreateManyInput;
  info?: SubjectInfoCreateManyWithoutSubjectInput;
  notes?: NoteCreateManyWithoutSubjectInput;
  prerequisites?: SubjectCreateManyInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  neptun: String;
  password: String;
  firstName?: String;
  lastName?: String;
  role: UserRole;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  neptun: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  role: () => Promise<UserRole>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  neptun: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface Subject {
  id: ID_Output;
  code: String;
  name: String;
  description: String;
}

export interface SubjectPromise extends Promise<Subject>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  faculty: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  students: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  info: <T = FragmentableArray<SubjectInfo>>(
    args?: {
      where?: SubjectInfoWhereInput;
      orderBy?: SubjectInfoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  notes: <T = FragmentableArray<Note>>(
    args?: {
      where?: NoteWhereInput;
      orderBy?: NoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  prerequisites: <T = FragmentableArray<Subject>>(
    args?: {
      where?: SubjectWhereInput;
      orderBy?: SubjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SubjectSubscription
  extends Promise<AsyncIterator<Subject>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  faculty: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  students: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  info: <T = Promise<AsyncIterator<SubjectInfoSubscription>>>(
    args?: {
      where?: SubjectInfoWhereInput;
      orderBy?: SubjectInfoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  notes: <T = Promise<AsyncIterator<NoteSubscription>>>(
    args?: {
      where?: NoteWhereInput;
      orderBy?: NoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  prerequisites: <T = Promise<AsyncIterator<SubjectSubscription>>>(
    args?: {
      where?: SubjectWhereInput;
      orderBy?: SubjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface User {
  id: ID_Output;
  email: String;
  neptun: String;
  password: String;
  firstName?: String;
  lastName?: String;
  role: UserRole;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  neptun: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  role: () => Promise<UserRole>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  neptun: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
}

export interface SubjectPreviousValues {
  id: ID_Output;
  code: String;
  name: String;
  description: String;
}

export interface SubjectPreviousValuesPromise
  extends Promise<SubjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface SubjectPreviousValuesSubscription
  extends Promise<AsyncIterator<SubjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface SubjectInfoEdge {
  node: SubjectInfo;
  cursor: String;
}

export interface SubjectInfoEdgePromise
  extends Promise<SubjectInfoEdge>,
    Fragmentable {
  node: <T = SubjectInfoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubjectInfoEdgeSubscription
  extends Promise<AsyncIterator<SubjectInfoEdge>>,
    Fragmentable {
  node: <T = SubjectInfoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SubjectInfoPreviousValues {
  id: ID_Output;
  title: String;
  subtitle?: String;
  text: String;
}

export interface SubjectInfoPreviousValuesPromise
  extends Promise<SubjectInfoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  subtitle: () => Promise<String>;
  text: () => Promise<String>;
}

export interface SubjectInfoPreviousValuesSubscription
  extends Promise<AsyncIterator<SubjectInfoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  subtitle: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubject {
  count: Int;
}

export interface AggregateSubjectPromise
  extends Promise<AggregateSubject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubjectSubscription
  extends Promise<AsyncIterator<AggregateSubject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubjectInfoSubscriptionPayload {
  mutation: MutationType;
  node: SubjectInfo;
  updatedFields: String[];
  previousValues: SubjectInfoPreviousValues;
}

export interface SubjectInfoSubscriptionPayloadPromise
  extends Promise<SubjectInfoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubjectInfoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubjectInfoPreviousValuesPromise>() => T;
}

export interface SubjectInfoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubjectInfoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubjectInfoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubjectInfoPreviousValuesSubscription>() => T;
}

export interface SubjectConnection {
  pageInfo: PageInfo;
  edges: SubjectEdge[];
}

export interface SubjectConnectionPromise
  extends Promise<SubjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubjectEdge>>() => T;
  aggregate: <T = AggregateSubjectPromise>() => T;
}

export interface SubjectConnectionSubscription
  extends Promise<AsyncIterator<SubjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubjectSubscription>() => T;
}

export interface Comment {
  id: ID_Output;
  text: String;
  locationInText: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  locationInText: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  note: <T = NotePromise>() => T;
  author: <T = UserPromise>() => T;
  replies: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  upvotes: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  locationInText: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  note: <T = NoteSubscription>() => T;
  author: <T = UserSubscription>() => T;
  replies: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  upvotes: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface NoteEdge {
  node: Note;
  cursor: String;
}

export interface NoteEdgePromise extends Promise<NoteEdge>, Fragmentable {
  node: <T = NotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface NoteEdgeSubscription
  extends Promise<AsyncIterator<NoteEdge>>,
    Fragmentable {
  node: <T = NoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentPreviousValues {
  id: ID_Output;
  text: String;
  locationInText: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  locationInText: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  locationInText: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateSubjectInfo {
  count: Int;
}

export interface AggregateSubjectInfoPromise
  extends Promise<AggregateSubjectInfo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubjectInfoSubscription
  extends Promise<AsyncIterator<AggregateSubjectInfo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubjectInfo {
  id: ID_Output;
  title: String;
  subtitle?: String;
  text: String;
}

export interface SubjectInfoPromise extends Promise<SubjectInfo>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  subtitle: () => Promise<String>;
  text: () => Promise<String>;
  subject: <T = SubjectPromise>() => T;
}

export interface SubjectInfoSubscription
  extends Promise<AsyncIterator<SubjectInfo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  subtitle: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  subject: <T = SubjectSubscription>() => T;
}

export interface SubjectInfoConnection {
  pageInfo: PageInfo;
  edges: SubjectInfoEdge[];
}

export interface SubjectInfoConnectionPromise
  extends Promise<SubjectInfoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubjectInfoEdge>>() => T;
  aggregate: <T = AggregateSubjectInfoPromise>() => T;
}

export interface SubjectInfoConnectionSubscription
  extends Promise<AsyncIterator<SubjectInfoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubjectInfoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubjectInfoSubscription>() => T;
}

export interface AggregateNote {
  count: Int;
}

export interface AggregateNotePromise
  extends Promise<AggregateNote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNoteSubscription
  extends Promise<AsyncIterator<AggregateNote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubjectSubscriptionPayload {
  mutation: MutationType;
  node: Subject;
  updatedFields: String[];
  previousValues: SubjectPreviousValues;
}

export interface SubjectSubscriptionPayloadPromise
  extends Promise<SubjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubjectPreviousValuesPromise>() => T;
}

export interface SubjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubjectPreviousValuesSubscription>() => T;
}

export interface Note {
  id: ID_Output;
  text: Json;
  title: String;
  number: Int;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: NoteType;
}

export interface NotePromise extends Promise<Note>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<Json>;
  title: () => Promise<String>;
  number: () => Promise<Int>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  subject: <T = SubjectPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  type: () => Promise<NoteType>;
  upvotes: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface NoteSubscription
  extends Promise<AsyncIterator<Note>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<Json>>;
  title: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<Int>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  subject: <T = SubjectSubscription>() => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  type: () => Promise<AsyncIterator<NoteType>>;
  upvotes: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface NotePreviousValues {
  id: ID_Output;
  text: Json;
  title: String;
  number: Int;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: NoteType;
}

export interface NotePreviousValuesPromise
  extends Promise<NotePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<Json>;
  title: () => Promise<String>;
  number: () => Promise<Int>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<NoteType>;
}

export interface NotePreviousValuesSubscription
  extends Promise<AsyncIterator<NotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<Json>>;
  title: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<Int>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<NoteType>>;
}

export interface NoteSubscriptionPayload {
  mutation: MutationType;
  node: Note;
  updatedFields: String[];
  previousValues: NotePreviousValues;
}

export interface NoteSubscriptionPayloadPromise
  extends Promise<NoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotePreviousValuesPromise>() => T;
}

export interface NoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotePreviousValuesSubscription>() => T;
}

export interface NoteConnection {
  pageInfo: PageInfo;
  edges: NoteEdge[];
}

export interface NoteConnectionPromise
  extends Promise<NoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NoteEdge>>() => T;
  aggregate: <T = AggregateNotePromise>() => T;
}

export interface NoteConnectionSubscription
  extends Promise<AsyncIterator<NoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNoteSubscription>() => T;
}

export interface SubjectEdge {
  node: Subject;
  cursor: String;
}

export interface SubjectEdgePromise extends Promise<SubjectEdge>, Fragmentable {
  node: <T = SubjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubjectEdgeSubscription
  extends Promise<AsyncIterator<SubjectEdge>>,
    Fragmentable {
  node: <T = SubjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Json = any;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Note",
    embedded: false
  },
  {
    name: "NoteType",
    embedded: false
  },
  {
    name: "Subject",
    embedded: false
  },
  {
    name: "SubjectInfo",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
